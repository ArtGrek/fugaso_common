//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.2

use std::sync::Arc;
use async_trait::async_trait;
use essential_data::sequence_generator::{GeneratorDispatcher, LegacyHiloGenerator};
use sea_orm::entity::prelude::*;
use sea_orm::Unchanged;
use serde::{Deserialize, Serialize};
use crate::model::ActiveClone;
use crate::sequence_generator::IdGenerator;
#[cfg(feature = "redis")]
use redis_macros::{FromRedisValue, ToRedisArgs};
#[cfg(feature = "redis")]
use essential_data::active_store::{ActiveStore, StoreValue};

#[derive(Debug, PartialEq, Eq, Hash, Clone,
EnumIter, DeriveActiveEnum, Deserialize, Serialize, Default)]
#[sea_orm(rs_type = "String", db_type = "String(Some(15))")]
#[allow(non_camel_case_types)]
pub enum ActionKind {
    #[sea_orm(string_value = "BET")]
    #[default]
    BET,
    #[sea_orm(string_value = "SPIN")]
    SPIN,
    #[sea_orm(string_value = "BET_LINE")]
    BET_LINE,
    #[sea_orm(string_value = "BET_LINE_DENOM")]
    BET_LINE_DENOM,
    #[sea_orm(string_value = "BET_LINE_REELS")]
    BET_LINE_REELS,
    #[sea_orm(string_value = "FREE_COLLECT")]
    FREE_COLLECT,
    #[sea_orm(string_value = "COLLECT")]
    COLLECT,
    #[sea_orm(string_value = "COLLECT_START")]
    COLLECT_START,
    #[sea_orm(string_value = "FREE_COLLECT_START")]
    FREE_COLLECT_START,
    #[sea_orm(string_value = "HALF_COLLECT")]
    HALF_COLLECT,
    #[sea_orm(string_value = "CLOSE")]
    CLOSE,
    #[sea_orm(string_value = "GAMBLE_PLAY")]
    GAMBLE_PLAY,
    #[sea_orm(string_value = "GAMBLE_END")]
    GAMBLE_END,
    #[sea_orm(string_value = "GAMBLE_FREE_END")]
    GAMBLE_FREE_END,
    #[sea_orm(string_value = "FREE_SPIN")]
    FREE_SPIN,
    #[sea_orm(string_value = "FREESPIN_START")]
    FREESPIN_START,
    #[sea_orm(string_value = "RESPIN")]
    RESPIN,
    #[sea_orm(string_value = "RESPIN_START")]
    RESPIN_START,
    #[sea_orm(string_value = "DROP")]
    DROP,
    #[sea_orm(string_value = "DROP_START")]
    DROP_START,
    #[sea_orm(string_value = "BONUS")]
    BONUS,
    #[sea_orm(string_value = "BONUS_START")]
    BONUS_START,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Default)]
#[sea_orm(table_name = "game_scale_action")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: i64,
    #[sea_orm(column_name = "actdescr")]
    pub act_descr: Option<ActionKind>,
    pub amount: i64,
    #[sea_orm(column_name = "freegames")]
    pub free_games: Option<String>,
    pub holds: Option<String>,
    pub lines: Option<String>,
    #[sea_orm(column_name = "nextact")]
    pub next_act: Option<ActionKind>,
    #[sea_orm(column_name = "nextcombo")]
    pub next_combo: i32,
    #[sea_orm(column_name = "reelcombo")]
    pub reel_combo: i32,
    #[sea_orm(column_name = "reelstops")]
    pub reel_stops: Option<String>,
    #[sea_orm(column_name = "timedone")]
    pub time_done: Option<DateTime>,
    pub round_id: Option<i64>,
    pub cards: Option<String>,
    pub choice: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub special: Option<String>,
    #[sea_orm(unique, column_name = "externalid")]
    pub external_id: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub custom: Option<String>,
    pub grid: Option<String>,
    pub remote_code: Option<i32>,
    #[sea_orm(column_type = "Text", nullable)]
    pub error_info: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
    belongs_to = "super::fugaso_round::Entity",
    from = "Column::RoundId",
    to = "super::fugaso_round::Column::Id",
    on_update = "NoAction",
    on_delete = "NoAction"
    )]
    Round,
}

impl Related<super::fugaso_round::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Round.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[async_trait]
impl<G: IdGenerator + Send + Sync> GeneratorDispatcher<G> for Model {
    async fn call(s: &G) -> Result<i64, DbErr> {
        s.gen_action().await
    }
}

pub fn create_sequence(pool: Arc<DatabaseConnection>) -> LegacyHiloGenerator {
    LegacyHiloGenerator::new(
        "game_scale_action_sequence",
        49,
        pool,
    )
}

impl ActiveClone<ActiveModel> for Model {
    fn clone_active_model(&self) -> ActiveModel {
        ActiveModel {
            id: Unchanged(self.id),
            act_descr: Unchanged(self.act_descr.clone()),
            amount: Unchanged(self.amount),
            free_games: Unchanged(self.free_games.clone()),
            holds: Unchanged(self.holds.clone()),
            lines: Unchanged(self.lines.clone()),
            next_act: Unchanged(self.next_act.clone()),
            next_combo: Unchanged(self.next_combo),
            reel_combo: Unchanged(self.reel_combo),
            reel_stops: Unchanged(self.reel_stops.clone()),
            time_done: Unchanged(self.time_done),
            round_id: Unchanged(self.round_id),
            cards: Unchanged(self.cards.clone()),
            choice: Unchanged(self.choice.clone()),
            special: Unchanged(self.special.clone()),
            external_id: Unchanged(self.external_id.clone()),
            custom: Unchanged(self.custom.clone()),
            grid: Unchanged(self.grid.clone()),
            remote_code: Unchanged(self.remote_code),
            error_info: Unchanged(self.error_info.clone()),
        }
    }

    fn unchanged_active_model() -> ActiveModel {
        ActiveModel {
            id: Unchanged(0),
            act_descr: Unchanged(Some(ActionKind::CLOSE)),
            amount: Unchanged(0),
            free_games: Unchanged(None),
            holds: Unchanged(None),
            lines: Unchanged(None),
            next_act: Unchanged(None),
            next_combo: Unchanged(0),
            reel_combo: Unchanged(0),
            reel_stops: Unchanged(None),
            time_done: Unchanged(None),
            round_id: Unchanged(None),
            cards: Unchanged(None),
            choice: Unchanged(None),
            special: Unchanged(None),
            external_id: Unchanged(None),
            custom: Unchanged(None),
            grid: Unchanged(None),
            remote_code: Unchanged(None),
            error_info: Unchanged(None),
        }
    }
}

#[cfg(feature = "redis")]
#[derive(Debug, DeriveIntoActiveModel, Default, Clone, Serialize, Deserialize, ToRedisArgs, FromRedisValue)]
pub struct StoreModel {
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub id: StoreValue<i64>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub act_descr: StoreValue<Option<ActionKind>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub amount: StoreValue<i64>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub free_games: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub holds: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub lines: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub next_act: StoreValue<Option<ActionKind>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub next_combo: StoreValue<i32>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub reel_combo: StoreValue<i32>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub reel_stops: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub time_done: StoreValue<Option<DateTime>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub round_id: StoreValue<Option<i64>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub cards: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub choice: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub special: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub external_id: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub custom: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub grid: StoreValue<Option<String>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub remote_code: StoreValue<Option<i32>>,
    #[serde(skip_serializing_if = "StoreValue::is_none", default)]
    pub error_info: StoreValue<Option<String>>,
}

#[cfg(feature = "redis")]
impl ActiveStore for ActiveModel {
    type R = StoreModel;

    fn to_active_store(self) -> Self::R {
        StoreModel {
            id: self.id.into(),
            act_descr: self.act_descr.into(),
            amount: self.amount.into(),
            free_games: self.free_games.into(),
            holds: self.holds.into(),
            lines: self.lines.into(),
            next_act: self.next_act.into(),
            next_combo: self.next_combo.into(),
            reel_combo: self.reel_combo.into(),
            reel_stops: self.reel_stops.into(),
            time_done: self.time_done.into(),
            round_id: self.round_id.into(),
            cards: self.cards.into(),
            choice: self.choice.into(),
            special: self.special.into(),
            external_id: self.external_id.into(),
            custom: self.custom.into(),
            grid: self.grid.into(),
            remote_code: self.remote_code.into(),
            error_info: self.error_info.into(),
        }
    }
}